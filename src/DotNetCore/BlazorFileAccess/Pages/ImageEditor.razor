@page "/image-editor"
@inject FileSystemAccessService FileSystemAccessService
@inject IJSRuntime jSRuntime

<PageTitle>ImageEditor</PageTitle>
<div>
    <button @onclick="OpenFilePicker" class="btn btn-primary">Open Image</button>
</div>
@if (FileHandle != null)
{
    <div class="row">
        <div class="form-group col">
            <label for="canvasSize">Canvas Size:</label>
            <input id="canvasSize" type="number" @oninput="WriteCanvasSize" class="form-control" value=@CanvasSize/>
        </div>
         <div class="form-group col">
            <label for="topText">Top Text:</label>
            <input id="topText" @oninput="WriteTopText" class="form-control" />
        </div>
        <div class="form-group col">
            <label for="bottomText">Bottom Text:</label>
            <input id="bottomText" @oninput="WriteBottomText" class="form-control" />
        </div>
    </div>
    <br />
    <button class="btn btn-primary" @onclick=Save>Save</button>
    <br />
}
<div>
    <canvas @ref=CanvasReference width=@CanvasSize height=@CanvasSize></canvas>
</div>


<div>
    <button @onclick="OpenDictoryPicker" class="btn btn-primary">Open Directory</button>
</div>
<table class="table">
    <thead>
        <tr>
            <th>File Name</th>
            <th>File Type</th>
            <th>Size</th>
        </tr>
    </thead>
    <tbody>
        @foreach (var fileModel in RootDictoryModel.Children)
        {
            <tr>
                <td>@fileModel.Name</td>
                <td>@fileModel.Kind</td>
                <td>@ReadableByteSize(@fileModel.Size)</td>
            </tr>
        }
    </tbody>
</table>


@code {
    private FileSystemFileHandle? FileHandle;
    private FileHandler? File;
    private IJSObjectReference? JSImageBitmap;
    private ElementReference CanvasReference { get; set; }
    private double CanvasSize = 200;

    private double ImageDrawHeight;
    private double ImageDrawWidth;

    private IJSObjectReference? JSCanvas;
    private IJSObjectReference? JS2dContext;

    private string TopText = "";
    private string BottomText = "";
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        JSCanvas = await jSRuntime.InvokeAsync<IJSObjectReference>("jSReference", CanvasReference);
        JS2dContext = await JSCanvas.InvokeAsync<IJSObjectReference>("getContext", "2d");
    }

    // open dictory
    protected DictoryModel RootDictoryModel = new(FileSystemHandleKind.Directory, "Root");

    protected async Task OpenFilePicker()
    {
        try
        {
            var options = new OpenFilePickerOptions()
            {
                Types = new FilePickerAcceptType[]
                {
                new FilePickerAcceptType()
                {
                    Description = "Images",
                    Accept = new() { { "image/*", new string[] { ".png", ".gif", ".jpeg", ".jpg" } } }
                }
                },
                Multiple = false,
                StartIn = WellKnownDirectory.Pictures
            };
            var fileHandlers = await FileSystemAccessService.ShowOpenFilePickerAsync(options);
            FileHandle = fileHandlers.Single();
        }
        catch(JSException jsex)
        {
            Console.WriteLine(jsex);
        }
        finally
        {
            if (FileHandle != null)
            {
                File = await FileHandle.GetFileAsync();
                var jsBlob = File.JSReference;
                JSImageBitmap = await jSRuntime.InvokeAsync<IJSObjectReference>("createImageBitmap", jsBlob);
                await DrawImage();
            }
        }
    }

    public async Task DrawImage()
    {
        if (JS2dContext == null) return;
        var imageWidth = await jSRuntime.InvokeAsync<double>("getAttribute", JSImageBitmap, "width");
        var imageHeight = await jSRuntime.InvokeAsync<double>("getAttribute", JSImageBitmap, "height");
        ImageDrawWidth = (imageWidth > imageHeight ? 1 : imageWidth / imageHeight) * CanvasSize;
        ImageDrawHeight = (imageWidth < imageHeight ? 1 : imageHeight / imageWidth) * CanvasSize;
        await jSRuntime.InvokeVoidAsync("setAttribute", JSCanvas, "width", ImageDrawWidth);
        await jSRuntime.InvokeVoidAsync("setAttribute", JSCanvas, "height", ImageDrawHeight);
        await JS2dContext.InvokeVoidAsync("drawImage", JSImageBitmap, 0, 0, ImageDrawWidth, ImageDrawHeight);
    }

    protected async Task WriteCanvasSize(ChangeEventArgs eventArgs)
    {
        CanvasSize = double.Parse((string)eventArgs.Value);
        await WriteTextAsync();
    }

    public async Task WriteTextAsync()
    {
        if (JS2dContext == null) return;
        await DrawImage();
        // Set Draw style
        await jSRuntime.InvokeVoidAsync("setAttribute", JS2dContext, "font", "bold 48px impact");
        await jSRuntime.InvokeVoidAsync("setAttribute", JS2dContext, "textAlign", "center");
        await jSRuntime.InvokeVoidAsync("setAttribute", JS2dContext, "fillStyle", "white");
        await jSRuntime.InvokeVoidAsync("setAttribute", JS2dContext, "strokeStyle", "black");
        await jSRuntime.InvokeVoidAsync("setAttribute", JS2dContext, "lineWidth", "1");
        // Top Text
        await JS2dContext.InvokeVoidAsync("fillText", TopText, ImageDrawWidth / 2, 60, ImageDrawWidth - 24);
        await JS2dContext.InvokeVoidAsync("strokeText", TopText, ImageDrawWidth / 2, 60, ImageDrawWidth - 24);
        // Bottom Text
        await JS2dContext.InvokeVoidAsync("fillText", BottomText, ImageDrawWidth / 2, ImageDrawHeight - 12, ImageDrawWidth - 24);
        await JS2dContext.InvokeVoidAsync("strokeText", BottomText, ImageDrawWidth / 2, ImageDrawHeight - 12, ImageDrawWidth - 24);
    }

    protected async Task WriteTopText(ChangeEventArgs eventArgs)
    {
        TopText = (string)eventArgs.Value;
        await WriteTextAsync();
    }

    protected async Task WriteBottomText(ChangeEventArgs eventArgs)
    {
        BottomText = (string)eventArgs.Value;
        await WriteTextAsync();
    }

    public async Task Save()
    {
        FileSystemFileHandle? saveFileHandle = null;
        try
        {
            var options = new SaveFilePickerOptions()
            {
                StartIn = WellKnownDirectory.Pictures,
                SuggestedName = string.Concat("editor_", FileHandle.Name)
            };
            saveFileHandle = await FileSystemAccessService.ShowSaveFilePickerAsync(options);
        }
        catch (JSException jsex)
        {
            Console.WriteLine(jsex);
        }
        finally
        {
            if (saveFileHandle != null && JSCanvas != null)
            {
                var blobCallback = new BlobCallback(jSRuntime, await FileSystemAccessService.HelperAsync());
                blobCallback.Callback = async (BlobHandler blobhandler) =>
                   {
                       var writable = await saveFileHandle.CreateWritableAsync();
                       await writable.WriteAsync(blobhandler);
                       await writable.CloseAsync();
                   };
                await blobCallback.ToBlobAsync(JSCanvas);
            }
        }
    }

    protected async Task OpenDictoryPicker()
    {
        FileSystemDirectoryHandle? directoryHandle = null;
        try
        {
            var options = new DirectoryPickerOptions() { StartIn = WellKnownDirectory.Pictures };
            directoryHandle = await FileSystemAccessService.ShowDirectoryPickerAsync(options);
        }
        catch (JSException ex)
        {
            Console.WriteLine(ex);
        }
        finally
        {
            if (directoryHandle != null)
            {
                await BreadthFirstTraversal(directoryHandle);
            }
        }
    }

    // Breadth First Traversal of the directories.
    private async Task BreadthFirstTraversal(FileSystemDirectoryHandle directoryHandle)
    {
        var values = await directoryHandle.ValuesAsync();
        var queue = new Queue<(DictoryModel entity, FileSystemDirectoryHandle dir, FileSystemHandle value)>();
        for (int i = 0; i < values.Count(); i++)
        {
            var value = values[i];
            var dicModel = new DictoryModel(value.Kind, value.Name);
            RootDictoryModel.Children.Add(dicModel);
            queue.Enqueue((dicModel, directoryHandle, value));
            StateHasChanged();
        }
        while (queue.Count > 0)
        {
            var (dicModel, dir, value) = queue.Dequeue();
            if (value.Kind is FileSystemHandleKind.File)
            {
                var fileSystemHandle = await dir.GetFileHandleAsync(value.Name);
                var file = await fileSystemHandle.GetFileAsync();
                dicModel.Size = file.Size;
            }
            else
            {
                var fileSystemDirectoryHandle = await dir.GetDirectoryHandleAsync(value.Name);
                
                var innerValues = await fileSystemDirectoryHandle.ValuesAsync();
                foreach (var innerValue in innerValues)
                {
                    var innerEntity = new DictoryModel(innerValue.Kind, innerValue.Name);
                    dicModel.Children.Add(innerEntity);
                    queue.Enqueue((innerEntity, fileSystemDirectoryHandle, innerValue));
                }
            }
            StateHasChanged();
        }
    }

    private string ReadableByteSize(ulong size)
    {
        string[] sizes = { "B", "KB", "MB", "GB", "TB" };
        int order = 0;
        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size = size / 1024;
        }

        // Adjust the format string to your preferences. For example "{0:0.#}{1}" would
        // show a single decimal place, and no space.
        return String.Format("{0:0.##} {1}", size, sizes[order]);
    }
}

